// ignore_for_file: always_specify_types,  leading_newlines_in_multiline_strings
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes
// ignore_for_file: unnecessary_brace_in_string_interps

class I18nTemplate {
  RegExp stringInterpolationRegExp = RegExp(
    r'({\s*[a-z]+\s*}+)',
    caseSensitive: false,
    multiLine: true,
  );

  String license = '''
/// Generate by [resource_generator](https://github.com/CaiJingLong/flutter_resource_generator) library.
/// PLEASE DO NOT EDIT MANUALLY.
///
// ignore_for_file: non_constant_identifier_names,unnecessary_brace_in_string_interps,non_constant_identifier_names

/// WARNING: This file is automatically generated. DO NOT EDIT, all your changes would be lost.\n
''';

  String get classDeclare => 'mixin AppLocalizationLookup {\n';
  String get classDeclareFunctions => '''

  Map<String, dynamic> _content = {};

  set content(Map<String, dynamic> loadedContent) {
    _content = loadedContent;
  }

  RegExp stringInterpolationRegExp = RegExp(
    r'({s*[a-z]+s*}+)',
    caseSensitive: false,
    multiLine: true,
  );

  String parsePlaceholder(fallbackValue, String key, Map<String, dynamic> placeholders) {
    final String? value = _content[key];
    if (value != null) {
      return value.replaceAllMapped(stringInterpolationRegExp, (match) {
        final matchString = value.substring(match.start, match.end);
        final parameter = value.substring(match.start + 1, match.end - 1).trim();

        if (!placeholders.containsKey(parameter) || placeholders[parameter] == null) {
          return matchString;
        }
        return placeholders[parameter].toString();
      });
    }
    return fallbackValue;
  }
\n''';

  String get blankLine => '\n\n';

  List<String> parseParameters(String value) {
    final Iterable<RegExpMatch> matches =
        stringInterpolationRegExp.allMatches(value);

    final parameters = <String>[];
    for (final RegExpMatch match in matches) {
      final String parameter =
          value.substring(match.start + 1, match.end - 1).trim();

      if (parameters.contains(parameter)) {
        continue;
      }
      parameters.add(parameter);
    }

    return parameters;
  }

  String get tripleQuotes => "'''";
  String get classDeclareFooter => '}\n';

  String fallbackValue(String value) {
    String mappedValue = value;
    final Iterable<RegExpMatch> matches =
        stringInterpolationRegExp.allMatches(value);
    if (matches.isNotEmpty) {
      mappedValue = value.replaceAllMapped(stringInterpolationRegExp, (match) {
        final matchString = value.substring(match.start, match.end);

        return '\$${matchString}';
      });
    }

    return "'${mappedValue}'";
  }

  String formatFiled(String key, String? value) {
    if (value != null) {
      final parameters = parseParameters(value);

      if (parameters.isEmpty) {
        return '''  String get ${key} => _content['${key}'] ?? ${fallbackValue(value)};\n''';
      }

      final String placeholders = parameters
          .map((parameter) => "'${parameter}': ${parameter},")
          .join('\n      ');

      return '''  String ${key}(${parameters.join(', ')}) {
        return parsePlaceholder(${fallbackValue(value)}, '${key}', {
          ${placeholders}
        });
      }\n''';
    } else {
      return '''  String get ${key} => _content['${key}'] ?? ''; n''';
    }
  }
}
